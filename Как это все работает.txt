Пользователь заходит на сайт, т.е. запрашивает страницу. Задача React отрисовать html-страницу для пользователя. Т.е. вернуть html-код внутри метода render.
Обычно принято разделять компоненты на smart-components и dump-components. Smart - это компонент, который получает и осуществляет основное управление данными, 
и передает их в дочерние dump-компоненты. Dump-компоненты это компоненты, отвечающие за небольшую область на странице(кнопки, таблицы, формы и другие более мелкие 
элементы). Dump-компоненты повторно переиспользуются по всему проекту и обеспечивают стандартизацию, быструю разработку и правильную понятную архитектуру. Это 
разделение условно, потому как часто dump-компоненты также могут запрашивать данные и обрабатывать их(например компонент формы добавления чего-либо помещается 
внутрь радительского умного компонента и получает от него данные, но и сам может выполнять запросы на сервер непосредственно, а не через родителя - например, для
валидации поля - если мы хотим добавить название книги, а оно уже есть, мы должны узнать что оно есть в БД, чтобы предотвратить добавление)

Пример наша home.jsx:
1. браузер запрашивает страницу, выполняется render(т.к. это компонент на основе функции, а не класса, то это содержимое return())
2. также начинается работа с данными, устанавливается state, начинают выполняться useEffect`ы согласно установленніх правил, если в useEffect список зависимостей
пуст, этот эффект будет выполнен один раз, при первой загрузке страницы, как правило, в нем помещаются запросы на получение данных. Для нас не имеет значение откуда
(из нашей БД используя наш сервер и наше API, или из удаленного источника через их API напрямую, или из удаленного источника через наш сервер бекенд, из импортируемого 
json-файла, как это было в начале обучения либо каким еще другим способом, главное получить данные) и как эти данные будут получены, используя redux или прямой запрос 
(у нас обычный fetch, но используют и другие библиотеки - axios, например). Получив/или не получив данные, мы переходим к следующим действиям, как правило, - это 
сохранение в state для последующей работы с ними, чаще всего (почти всегда) для передачи дочерним dump-компонентам, но и не только мы можем по итогу выполнения операции 
на запрос данных сделать что-нибудь еще(перенаправление на другую страницу, например).
3. Возвращаемся к пункту 1. При первой отрисовке если у нас выполнялся items.map() внутри нашего return() - т.е. мы получали список книг, проходились по каждой книге из 
списка и отрисовывали её, - но до момента получения данных родительским компонентом (home.jsx) этот список был пуст. После того как у родителя был выполнен useEffect на
запрос данных и данные были получены, сохранены в state, наш компонент отслеживает состояние state всегда и если видит изменения в определенной переменной state, в нашем
случае это - массив books, react вызывает переотрисовку (rerender) нашего DOM, но не всей страницы, а той её части где используется массив books. Массив был пустой в 
начале - render, пришли данные книг из источника и изменился state - render, добавлена еще одна книга к существующим (условно 10) книгам - render, удалена - render.
3.1. Если внутри нашего родительского smart-компонента книги отрисовываются не на прямую, а при помощи дочернего dump-компонента, т.е. условный BooksList.jsx, который
принимает в качестве props список книг books и уже "внутри себя" выполняет books.map(), даже не храня их в своем уже локальном state, а отрисовывает напрямую из props,
также выполнит переотрисовку, т.к. список был изменен.
